# 페이지 생성 가이드

이 문서는 프로젝트의 페이지 생성 시 일관된 패턴과 원칙을 제시한다.

## 기본 원칙

### 1. 페이지 구성 철학
- **단일 책임**: 각 페이지는 하나의 명확한 목적을 가진다
- **일관성**: 동일한 기능은 동일한 방식으로 구현한다
- **사용자 경험**: 직관적이고 예측 가능한 인터페이스를 제공한다
- **접근성**: 키보드 네비게이션과 스크린 리더를 고려한다

### 2. 레이아웃 원칙
- **위에서 아래로**: 헤더 → 검색/필터 → 주요 컨텐츠 → 액션 버튼 순서
- **고정 요소**: 중요한 액션 버튼은 우하단에 고정 배치
- **일관된 간격**: 섹션 간 `gap-6` 사용으로 통일된 시각적 리듬 제공
- **반응형**: 다양한 화면 크기에서 적절히 동작

## 브레드크럼 네비게이션 처리

### 자동 처리 범위
**목록 페이지**까지는 메뉴 구조를 기반으로 자동 생성된다. URL 패턴 매칭을 통해 다음과 같이 처리된다:
- 정확한 경로 매칭 우선
- 부분 매칭으로 상세 페이지 지원
- 홈 → 대메뉴 → 중메뉴 → 소메뉴 순서

### 수동 처리 필요 범위
**상세, 생성, 수정 등 하위 페이지**는 `currentPageLabelAtom`을 사용하여 명시적으로 설정해야 한다.

#### 필수 구현 패턴

1. **Import 추가**
```tsx
import { useAtom } from 'jotai';
import { currentPageLabelAtom } from '@/store/ui';
```

2. **페이지 라벨 설정**
```tsx
const [, setCurrentPageLabel] = useAtom(currentPageLabelAtom);

useEffect(() => {
  setCurrentPageLabel({
    label: '페이지 제목',
    href: window.location.pathname,
  });
}, [setCurrentPageLabel]);
```

#### 페이지별 라벨 전략

**상세 페이지**
- `'항목명 상세'` 또는 `'항목명 상세 정보'`
- 예: `'관리자 상세'`, `'주차장 상세 정보'`

**생성 페이지**
- `'항목명 추가'` 또는 `'항목명 생성'`
- 예: `'관리자 추가'`, `'주차장 생성'`

**편집 페이지**
- `'항목명 수정'` 또는 `'항목명 편집'`
- 예: `'관리자 수정'`, `'비밀번호 변경'`

#### 동적 라벨 설정
데이터 로드 후 구체적 정보로 업데이트할 수 있다:

```tsx
// 초기 설정
useEffect(() => {
  setCurrentPageLabel({
    label: '관리자 상세',
    href: window.location.pathname,
  });
}, [setCurrentPageLabel]);

// 데이터 로드 후 업데이트
useEffect(() => {
  if (adminData) {
    setCurrentPageLabel({
      label: `${adminData.name} 상세`,
      href: window.location.pathname,
    });
  }
}, [adminData, setCurrentPageLabel]);
```

## 페이지 유형별 패턴

### 1. 목록 페이지 (List Page)

#### 목적과 역할
데이터의 **조회, 검색, 삭제, 생성 진입점** 역할을 한다. 사용자가 시스템의 데이터를 탐색하는 주요 허브 역할을 수행한다.

#### 브레드크럼 처리
**자동 처리**되므로 별도 설정 불필요. 메뉴 구조에 따라 브레드크럼이 자동 생성된다.

#### 필수 구성 요소
1. **PageHeader**: 페이지 정체성과 주요 액션 제공
   - 제목과 설명으로 페이지 목적 명시
   - 우측에 "추가" 버튼으로 생성 페이지 진입점 제공
   
2. **AdvancedSearch**: 데이터 필터링 기능
   - 기본적으로 접힌 상태로 제공
   - 검색과 초기화 버튼으로 명확한 액션 구분
   - Field 컴포넌트들로 일관된 입력 UI 제공

3. **PaginatedTable**: 데이터 표시와 네비게이션
   - 행 클릭으로 상세 페이지 이동
   - 페이지네이션으로 대용량 데이터 처리
   - 액션 컬럼에 삭제 등 개별 작업 버튼 배치

4. **Dialog**: 사용자 확인과 피드백
   - 삭제 전 확인 다이얼로그
   - 성공/실패 결과 알림

#### 핵심 구현 원칙

1. **상태 관리 패턴**
   - 데이터 목록, 검색 필터, 다이얼로그 상태를 분리하여 관리
   - `useCallback`으로 핸들러 최적화, `useMemo`로 계산값 최적화
   - 에러 발생 시 빈 배열로 초기화하여 UI 깨짐 방지

2. **데이터 로드 전략**
   - 페이지 로드 시 기본 데이터 조회
   - 검색 시 필터 조건을 API에 전달
   - 로딩 중 상태 표시로 사용자 경험 개선

3. **네비게이션 패턴**
   - 테이블 행 클릭으로 상세 페이지 이동
   - URL 패턴은 일관되게 `/목록경로/상세/${id}` 형태
   - 뒤로가기 시 이전 검색 상태 유지 고려

4. **삭제 처리 흐름**
   - 삭제 버튼 클릭 → 확인 다이얼로그 → API 호출 → 로컬 상태 업데이트
   - 낙관적 업데이트로 즉시 UI 반영
   - 실패 시 원복 또는 새로고침 안내

#### Dialog 활용 전략
- **간단한 확인**: `title`과 `footer` props 활용
- **복잡한 내용**: `DialogHeader`, `DialogTitle`, `DialogDescription`, `DialogFooter` 서브 컴포넌트 조합
- **사용자 확인**: warning variant로 주의 환기
- **결과 알림**: success/error variant로 피드백 제공

### 2. 상세 페이지 (Detail Page)

#### 목적과 역할
개별 데이터의 **상세 조회와 편집**을 담당한다. 사용자가 특정 항목을 깊이 있게 탐색하고 필요시 수정할 수 있는 작업 공간을 제공한다.

#### 브레드크럼 처리
**수동 설정 필요**. 다음 패턴을 따라 구현한다:

```tsx
// 페이지 라벨 설정
useEffect(() => {
  setCurrentPageLabel({
    label: '관리자 상세',
    href: window.location.pathname,
  });
}, [setCurrentPageLabel]);

// 데이터 로드 후 구체적 정보로 업데이트 (선택사항)
useEffect(() => {
  if (data?.name) {
    setCurrentPageLabel({
      label: `${data.name} 상세`,
      href: window.location.pathname,
    });
  }
}, [data, setCurrentPageLabel]);
```

#### 핵심 디자인 패턴

1. **이중 모드 설계**
   - **조회 모드**: 데이터를 읽기 전용으로 표시
   - **편집 모드**: 필드 수정 가능, 저장 버튼 활성화
   - Lock/Unlock 아이콘으로 현재 모드 직관적 표시

2. **네비게이션 구조**
   - 좌측 뒤로가기 버튼으로 목록 페이지 복귀
   - 우측 편집 토글 버튼으로 모드 전환
   - 페이지 제목에 대상 항목 식별 정보 표시

3. **사용자 경험 최적화**
   - 편집 모드 진입 시 변경사항 실시간 추적
   - 저장 버튼은 변경사항이 있을 때만 표시
   - 우하단 고정 배치로 스크롤과 무관하게 접근 가능

4. **데이터 무결성 보장**
   - 원본 데이터와 편집 데이터 분리 관리
   - 편집 취소 시 원본 데이터로 즉시 복원
   - 변경사항 감지 후 사용자 확인 절차

#### 핵심 구현 원칙

1. **상태 분리 전략**
   - 원본 데이터(`data`)와 폼 데이터(`formData`) 독립 관리
   - 편집 시작 시점의 원본(`originalData`) 별도 보관
   - 로딩, 편집모드, 제출중 등 UI 상태 명확히 구분

2. **데이터 로드 패턴**
   - URL 파라미터에서 ID 추출 후 상세 API 호출
   - 로드 실패 시 목록 페이지로 자동 리다이렉트
   - 로딩 상태 표시로 사용자 대기 경험 개선

3. **편집 모드 관리**
   - 변경사항 있을 시 모드 해제 전 사용자 확인
   - 모드 해제 시 편집 내용을 원본으로 즉시 복원
   - 시각적 피드백으로 현재 모드 명확히 표시

4. **변경 감지 메커니즘**
   - 실시간으로 원본과 현재 값 비교
   - 변경 없으면 저장 버튼 비활성화
   - 필수 필드 검증과 변경 여부 모두 충족 시에만 저장 허용

5. **저장 프로세스**
   - 변경된 필드만 API에 전송하여 효율성 확보
   - 저장 성공 시 원본 데이터 업데이트 후 조회 모드 복귀
   - 실패 시 편집 모드 유지하여 재시도 기회 제공

### 3. 생성 페이지 (Create Page)

#### 목적과 역할
새로운 데이터를 **입력하고 생성**하는 전용 페이지다. 사용자가 시스템에 새로운 정보를 추가할 수 있는 진입점 역할을 한다.

#### 브레드크럼 처리
**수동 설정 필요**. 생성 관련 라벨로 설정한다:

```tsx
useEffect(() => {
  setCurrentPageLabel({
    label: '관리자 추가',
    href: window.location.pathname,
  });
}, [setCurrentPageLabel]);
```

#### 핵심 설계 원칙

1. **단순화된 워크플로우**
   - 상세 페이지와 달리 조회 모드 없이 입력에만 집중
   - 취소 시 목록 페이지로 즉시 복귀
   - 생성 완료 시 자동으로 목록 페이지 이동

2. **즉시 피드백**
   - 필수 필드 실시간 검증
   - 저장 버튼 활성화 상태로 진행 가능 여부 표시
   - 생성 중 로딩 상태로 중복 제출 방지

3. **사용자 안전망**
   - 입력 중 페이지 이탈 시 확인 절차 (선택사항)
   - 필수 정보 누락 시 명확한 안내
   - 생성 실패 시 입력 내용 보존

### 4. 공통 폼 컴포넌트 설계

#### 재사용성 원칙
동일한 데이터 모델에 대해 **생성, 편집, 조회** 세 가지 모드를 하나의 컴포넌트로 처리한다. 이를 통해 코드 중복을 방지하고 일관된 UI/UX를 보장한다.

#### 모드별 동작 차이

1. **Create 모드**
   - 모든 필드가 입력 가능 상태
   - 필수 필드에 `required` 표시
   - 기본값으로 빈 상태 또는 시스템 기본값 설정

2. **Edit 모드**
   - 수정 가능한 필드만 활성화
   - 고유 식별자(ID, 계정명 등)는 비활성화
   - 기존 데이터로 초기화

3. **View 모드**
   - 모든 필드를 읽기 전용으로 표시
   - 추가 정보 필드(등록일, 주차장 등) 표시
   - 입력 컴포넌트의 시각적 차이로 모드 구분

#### 폼 레이아웃 표준
- **GridForm** 컴포넌트로 일관된 라벨-컨텐츠 구조
- 라벨 너비 `120px`, 간격 `16px`로 통일
- **SimpleTextInput**, **SimpleDropdown** 등 Simple 시리즈 컴포넌트 활용
- `validationRule`로 입력 검증 규칙 적용

## UI 컴포넌트 라이브러리 활용

### 중형 모듈 컴포넌트 선택 가이드

페이지 개발 시 중형 규모의 기능 모듈이 필요한 경우, **프로젝트 UI 컴포넌트 라이브러리**를 우선 검토한다.

#### 참조 문서
- **UI 컴포넌트 인덱스**: `src/components/view/ui-components.md`
- **구현 소스**: `src/components/ui/**`
- **데모 페이지**: `src/app/lab/**`

#### 컴포넌트 검토 순서
1. **기능 요구사항 정의** → 필요한 기능과 UI 패턴 명확화
2. **라이브러리 검색** → ui-components.md에서 적합한 컴포넌트 확인
3. **데모 페이지 검증** → `/lab/` 경로에서 실제 동작과 스타일 확인
4. **적용 또는 커스터마이징** → 기존 컴포넌트 활용하거나 필요시 확장

#### 컴포넌트 부재 시 대응
라이브러리에 **적합한 컴포넌트가 없는 경우**, 작업을 중단하고 **사용자(기획자/디자이너)와 협의**한다:
- 기존 컴포넌트로 대체 가능한지 검토
- 새로운 컴포넌트 개발 필요성 및 우선순위 논의
- 개발 범위와 일정 재조정

## 개발 원칙과 규칙

### 1. 코드 구조 원칙

#### Import 순서 표준화
React → 외부 라이브러리 → UI 컴포넌트 → API 서비스 → 타입 정의 → 스토어 순서로 정리한다. 이를 통해 의존성 관계를 명확히 하고 코드 가독성을 높인다.

#### 상태 관리 패턴
- **로컬 상태**: `useState`로 컴포넌트 내부 데이터 관리
- **성능 최적화**: `useCallback`(함수), `useMemo`(계산값) 활용
- **부수효과 관리**: `useEffect`로 데이터 로드, 정리 작업 처리
- **전역 상태**: 페이지 라벨 등 공통 정보만 Jotai 활용

### 2. 에러 처리 전략

#### API 호출 패턴
모든 API 호출은 `try-catch`로 감싸고, `result.success` 확인 후 에러 메시지를 사용자에게 명확히 전달한다. 개발자 콘솔에는 상세 정보, 사용자에게는 이해하기 쉬운 메시지를 제공한다.

#### 사용자 경험 고려
- 네트워크 오류 시 재시도 안내
- 권한 부족 시 적절한 페이지 리다이렉트
- 예상치 못한 오류 시 안전한 상태로 복구

### 3. 네이밍 컨벤션

#### 컴포넌트명
- 페이지: `[도메인][기능]Page` (예: `AdminListPage`, `AdminDetailPage`)
- 하위 컴포넌트: `[도메인][용도]` (예: `AdminForm`, `AdminPasswordSection`)

#### 함수명
- 이벤트 핸들러: `handle[액션]` (예: `handleSubmit`, `handleCancel`)
- 데이터 처리: `load[데이터]`, `update[데이터]`, `validate[데이터]`

#### 상태 변수명
- 상태 플래그: `is[상태]` (예: `isLoading`, `isEditMode`)
- 데이터 존재 여부: `has[데이터]` (예: `hasChanges`, `hasPermission`)

### 4. UI/UX 일관성

#### 스타일링 표준
- **카드 형태**: `bg-card rounded-lg border border-border p-6`
- **섹션 간격**: `flex flex-col gap-6`
- **고정 버튼**: `fixed right-6 bottom-6 z-50`

#### 시각적 계층
- 페이지 제목 → 부제목 → 주요 컨텐츠 → 액션 버튼 순서
- 중요도에 따른 버튼 variant 선택 (`accent` > `default` > `ghost`)

### 5. 접근성 고려사항

- 모든 버튼에 `title` 속성으로 기능 설명 제공
- 로딩 중 상태 명시적 표시
- 키보드 네비게이션 지원
- 스크린 리더 친화적 마크업

### 6. 성능 최적화

- 불필요한 리렌더링 방지 위한 Hook 활용
- 대용량 데이터는 페이지네이션으로 분할
- 이미지 및 아이콘 최적화
- API 호출 최소화 및 중복 방지

이러한 원칙들을 일관되게 적용하면 유지보수성과 사용자 경험이 우수한 페이지를 구축할 수 있다.